## Index

- [Spring Framework의 기본 개념과 작동 방식](#spring-framework의-기본-개념과-작동-방식)
- [스프링의 기본 작동 방식과 매커니즘](#스프링의-기본-작동-방식과-매커니즘)
- [Spring의 핵심 개념](#spring의-핵심-개념)
- [의존성 주입 ( Dependency Injection )](#의존성-주입--dependency-injection)
- [IoC ( Inversion of Control, 제어의 역전 )](#ioc--inversion-of-control-제어의-역전)
- [AOP ( Aspect-Oriented Programming )](#aop--aspect-oriented-programming)
- [프록시 ( Proxy )](#프록시--proxy)
- [컴포넌트](#컴포넌트)
- [트랜잭션](#트랜잭션)
- [Argument resolver](#argument-resolver)
---

### Spring Framework의 기본 개념과 작동 방식
#### 컴포넌트와 빈 ( Components and Beans )
- **컴포넌트 ( Component ):** Spring 애플리케이션을 구성하는 기본적인 요소로, @Component 어노테이션을 사용하여 선언된 클래스입니다. 이는 Spring이 해당 클래스를 컨테이너에 빈으로 등록하게 합니다.

- **빈 ( Bean ):** Spring 컨테이너에 의해 관리되는 객체를 가리킵니다. 보통 Java 클래스로 정의되며, @Bean 어노테이션을 사용하여 Spring에 의해 인스턴스화되고 관리됩니다.

#### 스프링의 기본 작동 방식과 매커니즘
- **[의존성 주입 ( Dependency Injection )](#의존성-주입--dependency-injection):** 스프링은 의존성 주입을 통해 객체 간의 의존성을 낮추고 유연한 구조를 제공합니다. @Autowired 어노테이션을 통해 필요한 의존성을 주입받을 수 있습니다.

- **[IoC ( Inversion of Control, 제어의 역전 )](#ioc--inversion-of-control-제어의-역전):** 이는 객체 생성과 관리의 주도권을 프레임워크에 넘기는 것을 의미합니다. 객체의 생명주기와 의존성 관리를 스프링 컨테이너가 담당하므로, 개발자는 이를 신경 쓰지 않고 비즈니스 로직에 집중할 수 있습니다.

- **[AOP ( Aspect-Oriented Programming )](#aop--aspect-oriented-programming):** AOP는 횡단 관심사(cross-cutting concerns)를 모듈화하여 코드 중복을 줄이고 유지보수성을 높이는 기법입니다. 예를 들어, 로깅, 트랜잭션 관리 등을 별도의 모듈로 분리하여 적용할 수 있습니다.

#### Spring의 핵심 개념
- **ApplicationContext:** 스프링 애플리케이션을 구성하는 객체들을 관리하고 제공하는 중요한 인터페이스입니다. Bean의 라이프사이클 관리, 의존성 주입, 환경 설정 등을 담당합니다.

- **스프링 모듈:** 스프링은 여러 모듈로 구성되어 있으며, 각 모듈은 특정 기능을 담당합니다. 예를 들어, Spring Core, Spring MVC, Spring Data 등이 있습니다.


#### 의존성 주입 ( Dependency Injection ) 
- 의존성 주입은 객체 지향 프로그래밍에서 한 객체가 다른 객체를 필요로 할 때, 이를 직접 생성하거나 관리하지 않고 외부에서 필요한 객체를 주입받는 것
    - 간단히 말해서, 객체 A가 객체 B를 사용할 때, A가 B의 인스턴스를 직접 생성하지 않고, 어떤 방식으로든 B를 A에게 제공받는 것
        - 객체 간의 결합도가 낮아지고 유연성이 높아진다
- Spring에서는 주로 의존성 주입을 사용하여 객체 간의 관계를 설정
1. **인터페이스나 클래스를 통한 정의:** 먼저, 어떤 객체가 어떤 인터페이스를 구현하거나, 특정 클래스를 상속한다고 정의
2. **의존성을 선언:** 이 인터페이스나 클래스를 필요로 하는 객체는 스프링 컨테이너에게 이를 알려주고, 필요한 곳에 이 객체가 주입될 수 있도록 표시
3. **스프링 컨테이너에게 의존성 관리 위임:** 스프링 컨테이너가 객체 간의 의존성을 관리하고 필요한 객체를 생성

**정리**
- 간단한 예시를 통해 설명하자면, A라는 클래스에서 B라는 클래스의 인스턴스가 필요하다면, A 클래스 내부에 B 클래스의 인스턴스를 생성하는 것이 아니라, 외부에서 A에게 B의 인스턴스를 주입하는 방식
- 어차피 내가 필요한 객체를 코드 중간에서 객체를 생성하는 과정을 줄이기 위해, 시작부터 파라미터 또는 상위 개념에서 미리 준비를 시켜 놓고, 아무 때나 내가 필요할 때에 소환 할 수 있도록 함

**장점과 추가적인 설명**
1. **유연성과 테스트 용이성:** 객체 간의 결합도가 낮아지면서 코드 수정이나 유지보수가 용이해진다
    - 의존성 주입을 통해 모의 객체 ( mock objects ) 를 주입하여 테스트하기 쉬워집니다
2. **재사용성:** 동일한 객체를 여러 곳에서 사용할 수 있어 재사용성이 높아진다
    - 한 객체의 변경이 다른 객체에 미치는 영향을 최소화할 수 있다
3. **관심사의 분리:** 객체 생성과 의존성 해결에 대한 관심사를 개별 객체가 아닌 외부에서 관리함으로써, 개발자는 핵심 로직에 더 집중할 수 있다
4. **주입 방법의 다양성:** 생성자 주입, Setter 주입, 인터페이스 주입 등 다양한 방법을 통해 의존성을 주입할 수 있어 상황에 맞게 선택할 수 있다

- 의존성 주입은 객체 지향 설계의 핵심 중 하나로, 유연하고 확장 가능한 코드를 작성하는 데 중요한 역할
- 코드 중간에 필요한 객체를 생성하는 과정을 생략하고 미리 준비된 객체를 주입받아 사용함으로써 개발자는 더 효율적으로 코드를 작성 가능

#### IoC ( Inversion of Control, 제어의 역전 )
- IoC 는 객체지향 프로그래밍에서의 설계 원칙 중 하나로, 제어의 역전을 의미합니다. 기존에는 개발자가 프로그램의 제어 흐름을 직접 다루었지만, IoC에서는 프레임워크나 컨테이너가 제어 흐름을 맡아 객체의 생성과 생명 주기를 관리합니다

**주요 목적**
1. **코드의 결합도 낮추기:** IoC는 객체 간의 결합도를 낮춥니다. 객체 간의 의존성을 줄여, 수정이나 확장에 있어 더 유연하고 안정적인 코드를 작성할 수 있게 합니다.
2. **재사용성과 확장성 강화:** 제어의 역전으로 인해 코드의 모듈화가 쉬워지고, 이는 재사용성을 높이고 새로운 기능을 추가하는데 용이함을 의미합니다.
3. **테스트 용이성:** IoC를 적용한 코드는 테스트하기 쉽습니다. 의존성을 주입하거나 모의 객체를 사용하여 객체를 테스트하기 용이해집니다.
4. **의존성 관리:** IoC 컨테이너가 객체의 라이프사이클과 의존성을 관리함으로써, 개발자는 이를 신경 쓰지 않고 핵심 비즈니스 로직에 집중할 수 있습니다.
5. **확장 가능한 애플리케이션:** IoC를 통해 애플리케이션을 확장하거나 새로운 모듈을 추가하기가 쉽습니다. 새로운 기능을 도입할 때 전체 시스템을 변경할 필요 없이 추가 가능합니다.

- IoC는 의존성 주입(Dependency Injection)과 밀접한 관련이 있습니다. 의존성 주입은 IoC의 구체적인 구현 방식 중 하나로, 외부에서 객체의 의존성을 주입하는 것을 말합니다. 이러한 IoC 컨테이너를 통해 제어의 역전을 구현함으로써, 객체 간의 결합도를 낮추고 유연하고 확장 가능한 소프트웨어를 개발할 수 있습니다.

**메커니즘**
- IoC는 객체의 생명주기와 의존성 관리를 프레임워크나 컨테이너에게 맡기는 것을 의미합니다. 이것은 보통 아래와 같은 메커니즘을 통해 이루어집니다.

1. **인터페이스나 추상 클래스를 활용:** 일반적으로 인터페이스나 추상 클래스를 정의하고, 이를 구현하는 클래스를 만듭니다. 이 인터페이스나 추상 클래스를 통해 객체를 참조하면 실제로 어떤 클래스의 인스턴스가 생성되는지에 대한 결정은 런타임에 이루어집니다.
2. **의존성 주입 ( Dependency Injection ):** IoC의 핵심은 의존성 주입에 있습니다. 객체가 필요로 하는 의존성을 외부에서 주입받습니다. 이는 주로 생성자, Setter 메서드, 인터페이스 구현 등을 통해 이루어집니다.
3. **컨테이너 관리:** 스프링 프레임워크와 같은 IoC 컨테이너는 객체의 라이프사이클과 의존성을 관리합니다. 개발자가 객체를 직접 생성하고 관리하지 않고, IoC 컨테이너에게 객체의 생성과 소멸을 위임합니다. 이를 통해 컨테이너가 필요한 객체를 적절한 시점에 생성하고 주입하여 사용합니다.
4. **설정 파일 또는 어노테이션 사용:** IoC 컨테이너는 설정 파일 ( XML, YAML 등 ) 이나 어노테이션을 통해 객체 간의 관계와 의존성을 설정합니다. 이를 통해 컨테이너가 어떤 객체를 생성하고 주입해야 하는지를 명시합니다.
5. **생성자 주입, Setter 주입:** 주로 생성자 주입 ( Constructor Injection ) 과 Setter 주입 ( Setter Injection ) 이 사용됩니다. 생성자 주입은 객체 생성 시에 의존성을 주입하는 방식이고, Setter 주입은 Setter 메서드를 통해 의존성을 주입하는 방식입니다.

- 이러한 방식을 통해 IoC는 개발자가 객체의 생성과 의존성 관리에 대한 제어를 컨테이너에게 위임함으로써, 유연하고 확장 가능한 애플리케이션을 구축할 수 있도록 도와줍니다. 객체 간의 결합도를 낮추고, 유지보수 및 테스트 용이성을 높이는 데 중요한 역할을 합니다.

#### AOP ( Aspect-Oriented Programming )
- AOP ( Aspect-Oriented Programming ) 는 횡단 관심사 ( cross-cutting concerns ) 를 모듈화하여 코드 중복을 줄이고 유지보수성을 향상시키는 프로그래밍 패러다임입니다. 횡단 관심사란 여러 모듈에서 반복되는 로깅, 보안, 트랜잭션 관리 등과 같은 기능들을 말합니다.

**1. Aspect ( 관점 ) 정의**
- **Advice ( 조언 ):** 특정 관심사에 대한 구현을 담은 모듈입니다. 예를 들어, 메서드 호출 전에 실행할 코드, 메서드 호출 후에 실행할 코드 등이 Advice에 해당합니다.
- **Pointcut ( 결합점 ):** Advice 를 적용할 대상을 선별하는 규칙입니다. 메서드 호출, 필드 값 변경 등의 지점을 지정하여 Advice 를 적용할 위치를 결정합니다.
- **Join point ( 조인 포인트 ):** 애플리케이션 실행 중에 특정 시점을 가리킵니다. 메서드 호출 전, 후 또는 예외 발생 시 등이 Join point 에 해당합니다.
&nbsp;
- Pointcut 은 AOP를 적용할 대상을 선별하는 규칙을 나타내고, Join point는 Pointcut 에서 선택한 대상들 중에서 실제로 AOP 가 적용될 실행 지점을 나타냅니다. Pointcut 은 AOP가 적용될 대상을 지정하고, Join point 는 그 대상들 중에서 어느 지점에서 AOP 를 실행해야 하는지를 결정합니다.

**2. AOP 프레임워크를 통한 적용**
- AOP 를 사용하기 위해서는 주로 다음과 같은 방식으로 적용됩니다.

1. **[프록시 ( Proxy )](#프록시--proxy) 기반 AOP**
- AOP 프레임워크가 프록시 객체를 생성하여 원본 객체의 메서드 호출을 감싸는 방식입니다. 이 프록시 객체는 Pointcut 에 따라 Advice 를 실행하고, 원본 메서드를 호출하거나 호출을 차단할 수 있습니다.

2. **바이트코드 조작**
- AOP 프레임워크는 바이트코드를 조작하여 Advice 코드를 직접 삽입하는 방식입니다. 이를 통해 컴파일된 클래스 파일의 바이트코드를 변경하여 특정 지점에 Advice 를 삽입합니다.
- 이 방법은 컴파일된 클래스 파일의 바이트 코드를 변경함으로써 AOP를 구현합니다.

**예시**
- 예를 들어, 메서드 호출 시 로깅을 추가하고 싶을 때, AOP 를 사용하여 해당 메서드 호출에 로깅을 추가할 수 있습니다. Advice 에서는 로깅을 수행하는 코드를 작성하고, Pointcut 을 통해 특정 메서드 호출에 대해 Advice 를 실행하도록 설정합니다.
- 이러한 방식을 통해 AOP 는 핵심 비즈니스 로직과 횡단 관심사를 분리함으로써, 코드의 가독성을 높이고 유지보수를 용이하게 합니다. 코드 중복을 줄이고 관심사의 모듈화를 통해 시스템을 보다 효과적으로 관리할 수 있습니다.

##### 프록시 ( Proxy )
- 프록시는 원본 객체의 기능을 대신하는 객체로, 클라이언트 요청을 처리하고 그에 따른 추가적인 처리를 수행할 수 있는 중간자 역할을 합니다. 주로 프록시는 원본 객체의 접근을 제어하거나 보완하기 위해 사용됩니다.

**프록시의 특징**
- **접근 제어 및 보안 강화:** 프록시는 클라이언트와 원본 객체 사이에서 중재자 역할을 하기 때문에, 원본 객체에 직접 접근하는 것을 막거나 접근을 제어할 수 있습니다. 이를 통해 보안을 강화하거나 접근을 제한하는 등의 작업을 수행할 수 있습니다.
- **성능 개선 및 부가적인 작업:** 프록시는 원본 객체의 기능을 호출하기 전에 추가적인 작업을 수행할 수 있습니다. 예를 들어, 캐시 기능을 구현하여 특정 메서드의 결과를 저장하고, 동일한 요청이 들어오면 저장된 결과를 반환할 수 있습니다.
- **원본 객체의 분리:** 프록시를 이용하면 클라이언트는 실제 원본 객체를 직접 호출하는 대신 프록시 객체를 통해 작업을 수행할 수 있습니다. 이를 통해 클라이언트와 원본 객체 사이에 결합도를 줄이고, 객체의 변화에 영향을 최소화할 수 있습니다.

**AOP에서 프록시의 활용**
- AOP에서 프록시는 특정 Join point에서 Advice(조언)를 실행하거나 추가적인 작업을 수행하는 데 사용됩니다. AOP 프레임워크는 대상 객체를 감싸고, 클라이언트가 대상 객체에 직접 접근하는 대신 프록시를 통해 Advice를 적용합니다.
- 메서드 호출 앞 또는 뒤에 로깅을 추가하려면 AOP 프레임워크는 프록시 객체를 생성하여 클라이언트의 요청을 가로채고, 원본 객체의 메서드 호출 전후에 로깅을 수행하거나 추가적인 작업을 처리합니다.
- 프록시는 객체 지향 프로그래밍에서 중요한 개념으로, 객체의 기능을 보완하거나 변경하기 위해 중간에 끼어들어 추가적인 작업을 수행할 수 있도록 도와줍니다.

**웹 브라우저에서의 프록시**
- 네트워크 트래픽을 중계하고 필터링하여 사용자의 익명성을 보호하거나, 웹 페이지 접근을 더 효율적으로 관리하는 기능을 말합니다. 이는 사용자의 요청을 대신하여 외부 서버에 연결하고 응답을 받아오는 역할을 수행합니다.

**프록시의 주요 기능**
1. **익명성 보호**
    - 프록시는 사용자의 IP 주소를 숨기고, 대신 프록시 서버의 IP 주소를 사용하여 외부 서버와 통신합니다. 이를 통해 사용자의 익명성을 유지할 수 있습니다.
2. **캐싱**
    - 프록시는 이전에 요청한 내용을 저장하여 다음에 동일한 요청이 들어오면 저장된 내용을 제공함으로써 네트워크 대역폭을 절약하고 속도를 높일 수 있습니다.
3. **보안 필터링**
    - 프록시는 사용자가 악성 웹사이트에 접근하는 것을 막거나, 해로운 콘텐츠를 필터링하여 보안을 강화합니다.
4. **접근 제어**
    - 기업이나 학교 등에서는 프록시를 사용하여 특정 웹사이트에 대한 접근을 제어하거나, 내부 네트워크와 외부 사이트 간의 접근을 관리합니다.
- 브라우저에서 프록시를 설정하면, 해당 설정에 따라 웹 요청이 프록시 서버를 통해 전달되며, 이러한 기능들이 수행됩니다. 사용자는 프록시를 통해 안전하고 익명성을 유지하거나, 네트워크 트래픽을 관리하며 필터링할 수 있습니다.

### 컴포넌트
- 컴포넌트는 소프트웨어 개발에서 모듈화된 부분을 나타내며, 특정 기능이나 역할을 수행하는 독립적인 부분을 말합니다.
- 이러한 컴포넌트들은 재사용 가능하고 독립적으로 개발, 테스트, 유지보수가 가능하도록 설계됩니다.

**컴포넌트의 특징**
1. **모듈화 ( Modularity )**
    - 컴포넌트는 특정 기능이나 역할을 수행하기 위한 독립적인 단위로 분리됩니다. 이렇게 모듈화된 컴포넌트는 독립적으로 개발되고 테스트되어야 합니다.
2. **재사용성 ( Reusability )**
    - 컴포넌트는 다른 시스템이나 애플리케이션에서 재사용될 수 있도록 설계되어야 합니다. 재사용 가능한 컴포넌트는 비슷한 기능을 수행하는 다른 시스템에서도 활용될 수 있습니다.
3. **독립성 ( Independence )**
    - 컴포넌트는 다른 컴포넌트와 독립적으로 동작할 수 있어야 합니다. 이는 하나의 컴포넌트가 다른 컴포넌트에 영향을 주지 않고 독립적으로 개발되고 유지보수될 수 있음을 의미합니다.
4. **인터페이스 제공**
    - 컴포넌트는 외부에 제공하는 인터페이스를 통해 기능을 노출하고, 다른 컴포넌트나 시스템에서 해당 기능을 사용할 수 있도록 해야 합니다.

**예시**
- 웹 개발에서 컴포넌트는 특정 기능을 담당하는 라이브러리, 모듈, 혹은 코드 조각으로 볼 수 있습니다. 예를 들어, 웹 애플리케이션의 컴포넌트로는 사용자 인증을 처리하는 컴포넌트, 데이터베이스와 상호작용하는 컴포넌트, UI를 담당하는 컴포넌트 등이 있을 수 있습니다.
- 이러한 컴포넌트들은 각각이 독립적으로 구성되어 있으며, 필요에 따라 재사용하거나 새로운 기능을 개발할 때 조합하여 사용할 수 있습니다. 컴포넌트 기반의 개발은 유연하고 확장 가능한 시스템을 구축하는 데 도움을 줍니다.

**스프링에서 컴포넌트**
- 스프링 프레임워크에서 컴포넌트는 애플리케이션을 구성하는 핵심 요소 중 하나로, 주로 IoC 컨테이너에서 관리되는 객체를 나타냅니다

1. **@Component 어노테이션**
- 의미
    - @Component 어노테이션은 해당 클래스를 스프링 IoC 컨테이너의 관리 대상으로 지정합니다. 주로 일반적인 컴포넌트를 나타내는 데 사용됩니다.
- 예시
    - @Component 어노테이션을 사용하여 개발자가 정의한 클래스를 스프링 빈으로 등록할 수 있습니다.
2. **@Service, @Repository, @Controller**
    - 각각 @Service, @Repository, @Controller 어노테이션은 @Component를 확장한 것으로, 더 구체적인 역할을 명시하기 위해 사용됩니다.
    - **@Service** 비즈니스 로직을 담당하는 서비스 클래스를 나타냅니다.
    - **@Repository** 데이터 액세스와 관련된 기능을 담당하는 클래스(주로 데이터베이스 액세스)를 나타냅니다.
    - **@Controller** 웹 애플리케이션에서 HTTP 요청을 처리하는 컨트롤러 클래스를 나타냅니다.
3. **의존성 주입 ( Dependency Injection )**
    - 스프링에서 컴포넌트는 의존성 주입을 통해 서로 연결됩니다. 이를 통해 코드의 결합도를 낮추고 유연성을 높입니다.
    - @Autowired, @Qualifier, @Inject 등의 어노테이션을 사용하여 의존성을 주입합니다.
4. **AOP ( Aspect-Oriented Programming )**
    - 스프링의 AOP는 메서드 호출 전/후 등 특정 지점에서의 작업을 Advice로 정의하여 컴포넌트에 적용할 수 있습니다.
    - @Aspect 어노테이션을 사용하여 관점(Aspect)을 정의하고, @Before, @After, @Around 등의 Advice를 적용합니다.
5. **트랜잭션 관리**
    - 스프링은 트랜잭션 관리를 지원하며, @Transactional 어노테이션을 사용하여 트랜잭션을 적용할 수 있습니다.
    - @Transactional을 사용하면 메서드 실행이 트랜잭션 내에서 수행되도록 지정할 수 있습니다.
- 컴포넌트는 스프링 애플리케이션의 핵심이며, 이를 통해 모듈화된 코드를 개발하고, 의존성 주입, AOP, 트랜잭션 관리 등을 효과적으로 수행할 수 있습니다. 각 어노테이션은 특정한 의미와 기능을 나타내며, 스프링 개발에서 핵심적인 역할을 수행합니다.

### 트랜잭션
- 트랜잭션이란 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위를 말합니다. 이 작업의 단위는 하나 이상의 SQL 쿼리문이 묶여서 실행되는 것을 의미합니다. 트랜잭션은 ACID라고 불리는 네 가지 특성을 보장합니다.

**ACID 특성**
- **원자성(Atomicity)**
    - 모든 작업이 완전히 실행되거나 아예 실행되지 않아야 합니다. 즉, 트랜잭션 내의 작업은 일부만 반영되어서는 안 됩니다.
- **일관성(Consistency)**
    - 트랜잭션이 완료된 후에는 데이터베이스가 일관된 상태로 유지되어야 합니다. 즉, 트랜잭션이 일어나기 전 상태에서 일관성을 보장합니다.
- **격리성(Isolation)**
    - 동시에 여러 트랜잭션이 실행될 때 각 트랜잭션은 다른 트랜잭션의 작업에 영향을 받지 않도록 격리되어야 합니다.
- **지속성(Durability)**
    - 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 저장되어야 합니다. 즉, 시스템이 고장나더라도 데이터는 보존되어야 합니다.

**스프링에서의 트랜잭션**
- 스프링은 트랜잭션 관리를 위해 @Transactional 어노테이션과 AOP를 활용합니다. @Transactional 어노테이션을 사용하여 트랜잭션을 적용할 메서드를 지정할 수 있습니다. 이 어노테이션을 사용하면 해당 메서드는 트랜잭션 내에서 실행됩니다.
- 스프링은 또한 여러 트랜잭션 관리 전략을 지원합니다. JDBC, JPA, Hibernate 등의 다양한 데이터 액세스 기술에 대해 트랜잭션을 관리할 수 있습니다. 이러한 트랜잭션 관리 기능은 트랜잭션의 시작, 커밋, 롤백을 자동으로 처리하여 개발자가 트랜잭션 관리에 집중하지 않고도 안정적인 데이터베이스 작업을 수행할 수 있도록 도와줍니다.
- 스프링의 트랜잭션 관리는 데이터베이스 작업의 일관성과 안전성을 보장하며, 데이터베이스 관련 예외가 발생했을 때 롤백 등의 작업을 처리하여 데이터의 무결성을 지킵니다.

### Argument resolver
- HTTP 요청에 전달된 파라미터나 헤더 등의 값을 메서드의 파라미터로 변환하는 기능
- Argument resolver는 개념이며, Spring Framework와 같은 웹 프레임워크에서는 이 개념을 구체적으로 구현하는 클래스나 함수가 있습니다.
**종류**
- @RequestHeader
    - 어노테이션은 HTTP 헤더에서 값을 추출하여 메서드의 파라미터로 주입
- @RequestParam은
    - 쿼리 파라미터의 값을 받아오는 데 사용
- @PathVariable은
    - URL 경로 변수의 값을 가져오는 데 사용
- @RequestHeader
    - 어노테이션은 HTTP 헤더에서 값을 추출