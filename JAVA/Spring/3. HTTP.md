## Index

- [인터넷 네트워크](#인터넷-네트워크)
- [IP ( 인터넷 프로토콜 )](#ip--인터넷-프로토콜)
- [인터넷 프로토콜 스택의 4계층](#인터넷-프로토콜-스택의-4계층)
- [IP ( 인터넷 프로토콜 )](#ip--인터넷-프로토콜)
- [TCP](#tcp)
- [UDP](#udp)
- [PORT](#port)
- [DNS](#dns--domain-name-system)
- [URI ( Uniform Resource Identifier )](#uri--uniform-resource-identifier)
- [URL 문법](#url-문법)
- [웹 브라우저 요청 흐름](#웹-브라우저-요청-흐름)
- [HTTP ( HyperText Transfer Protocol )](#http--hypertext-transfer-protocol)
- [클라이언트 서버 구조](#클라이언트-서버-구조)
- [무상태 프로토콜](#무상태-프로토콜)
- [스테이스리스 ( Stateless )](#스테이트리스--stateless)
- [Stateful, Stateless 차이](#stateful-stateless-차이)
- [비 연결성 ( connectionless )](#비-연결성--connectionless)
- [HTTP 메시지](#http-메시지)
- [HTTP 메시지 구조](#http-메시지-구조)
- [시작 라인](#시작-라인)
- [HTTP 헤더](#http-헤더)
- [HTTP 메시지 바디](#http-메시지-바디)
- [HTTP 정리](#http-정리)
- [HTTP 메서드](#http-메서드)
- [API URI 설계](#api-uri-설계)
- [HTTP 메서드 종류](#http-메서드-종류)
- [GET](#get)
- [POST](#post)
---


### 인터넷 네트워크
- 인터넷 통신
- IP(Internet Protocol)
- TCP, UDP
- PORT
- DNS

#### 인터넷 프로토콜 스택의 4계층
- 애플리케이션 계층 - HTTP, FTP
- 전송 계층 - TCP, UDP
- 인터넷 계층 - IP
- 네트워크 인터페이스 계층

### IP ( 인터넷 프로토콜 )
**인터넷 프로토콜 역할**
- 지정한 IP 주소 ( IP Address ) 에 데이터 전달
- 패킷(Packet)이라는 통신 단위로 데이터 전달

**패킷 정보**
- 출발지 IP
- 목적지 IP
- 전송 데이터
- 기타

**IP 프로토콜의 한계**
- 비연결성
    - 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송
- 비신뢰성
    - 중간에 패킷이 사라지면?
    - 패킷이 순서대로 안오면?
- 프로그램 구분
    - 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면?

### TCP
- 전송 제어 프로토콜 ( Transmission Control Protocol )
&nbsp;
- 연결지향 - TCP 3 way handshake (가상 연결)
    - syn
    - syn + ack
    - ack ( 최근에는 ACK와 함께 데이터 전송 가능 )
- 데이터 전달 보증
- 순서 보장
- 신뢰할 수 있는 프로토콜
- 현재는 대부분 TCP 사용

**프로토콜 계층**
1. 프로그램이 Hello, world! 메시지 생성
2. SOCKET 라이브러리를 통해 전달
3. TCP 정보 생성, 메시지 데이터 포함
4. IP 패킷 생성, TCP 데이터 포함

**TCP/IP 패킷 정보**
- IP: 출발지 IP, 목적지 IP, 기타...
- TCP: 출발지 PORT, 목적지 PORT 전송 제어, 순서, 검증 정보...
& 전송 데이터

### UDP
- 사용자 데이터그램 프로토콜 ( User Datagram Protocol )
&nbsp;
- 하얀 도화지에 비유 ( 기능이 거의 없음 )
- 연결지향 X
- TCP 3 way handshake X
- 데이터 전달 보증 X
- 순서 보장 X
- 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름

**정리**
- IP와 거의 같다. + Port 정보 + 체크섬 정도만 추가
- 애플리케이션에서 추가 작업 필요

### PORT
- 한 번에 둘 이상의 연결을 위해
    - 유튜브
    - 게임
    - 화상통화
&nbsp;
- IP 를 통해 다양한 패캣들이 날아올 텐데 어떤 프로그램에서 필요한 패킷인지를 확인이 불가능
- TCP/IP 패킷에 출발지 IP + PORT, 목적지 IP + PORT 를 입력
- 같은 IP 내에서 프로세르를 구분 할 때 사용

**포트 번호**
- 0 ~ 65535: 할당 가능
- 0 ~ 1023: 잘 알려진 포트, 사용하지 않는 것이 좋음
    - FTP - 20, 21
    - TELNET - 23
    - HTTP - 80
    - HTTPS - 443

### DNS ( Domain Name System )
- 전화번호부
- 도메인 명을 IP 주소로 변환
&nbsp;
- IP 는 기억하기 어럽다
- IP 는 변경될 수 있다
&nbsp;
- 도메인을 구입 후 도메인명과 IP 를 등록
- 클라이언트는 DNS 서버에 도메인명을 전송
- DNS 서버는 도메인에 해당하는 IP 를 반환
- 클라이언트는 반환 받은 IP 를 통해 서버에 접속

### URI ( Uniform Resource Identifier )
- URI는 로케이터(locator), 이름(name) 또는 둘 다 추가로 분류될 수 있다
    - URL + URN
        - URL: Resource Locator
        - URN: Resource Name
&nbsp;
- Uniform: 리소스 식별하는 통일된 방식
- Resource: 자원, URI로 식별할 수 있는 모든 것 ( 제한 없음 )
- Identifier: 다른 항목과 구분하는데 필요한 정보

**URL, URN**
- URL: ( Locator ) 리소스가 있는 위치를 지정
- URN: ( Name ) 소스에 이름을 부여
- 위치는 변할 수 있지만, 이름은 변하지 않는다
- urn:isbn:8960777331 ( 어떤 책의 isbn URN )
- URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지 않음

#### URL 문법
- scheme://[userinfo@]host[:port][/path][?query][#fragment]
- https://www.google.com:443/search?q=hello&hl=ko
&nbsp;
- 프로토콜 ( https )
- 호스트명 ( www.google.com )
- 포트 번호 ( 443 )
- 패스 ( /search )
- 쿼리 파라미터 ( q=hello&hl=ko )

**scheme**
**scheme** : //[userinfo@]host[:port][/path][?query][#fragment]
**https** : //www.google.com:443/search?q=hello&hl=ko
- 주로 프로토콜 사용
- 프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
    - 예) http, https, ftp 등등
- http는 80 포트, https는 443 포트를 주로 사용, 포트는 생략 가능
https는 http에 보안 추가 ( HTTP Secure )

**userinfo**
scheme:// **[userinfo@]** host[:port][/path][?query][#fragment]
https://www.google.com:443/search?q=hello&hl=ko
- URL에 사용자정보를 포함해서 인증
- 거의 사용하지 않음

**host**
scheme://[userinfo@]**host**[:port][/path][?query][#fragment]
https://**www.google.com**:443/search?q=hello&hl=ko
- 호스트명
- 도메인명 또는 IP 주소를 직접 사용가능

**port**
scheme://[userinfo@]host **[:port]**[/path][?query][#fragment]
https://www.google.com **:443** /search?q=hello&hl=ko
- 포트 ( PORT )
- 접속 포트
- 일반적으로 생략, 생략시 http는 80, https는 443

**path**
scheme://[userinfo@]host[:port] **[/path]** [?query][#fragment]
https://www.google.com:443/ **search** ?q=hello&hl=ko
- 리소스 경로 ( path ), 계층적 구조
    - /home/file1.jpg
    - /members
    - /members/100, /items/iphone12

**query**
scheme://[userinfo@]host[:port][/path] **[?query]** [#fragment]
https://www.google.com:443/search **?q=hello&hl=ko**
- key=value 형태
- ?로 시작, &로 추가 가능 ?keyA=valueA&keyB=valueB
- query parameter, query string 등으로 불림, 웹서버에 제공하는 파라미터, 문자 형태

**fragment**
scheme://[userinfo@]host[:port][/path][?query] **[#fragment]**
https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html **#getting-started-introducing-spring-boot**
- fragment
- html 내부 북마크 등에 사용
- 서버에 전송하는 정보 아님

### 웹 브라우저 요청 흐름
https://www.google.com:443/search?q=hello&hl=ko

1. DNS 서버에 www.google.com 주소 조회 후 IP 주소 반환
2. HTTPS 이기에 443 포트 생략
3. HTTP 요청 메세지 생성
    ```
    GET /search?q=hello&hl=ko HTTP/1.1
    Host: www.google.com
    ```
4. HTTP 메세지 전송
    1. HTTP 메세지를 SOCKET 라이브러리를 통해 전달
    2. TCP/IP 패킷 생성 + HTTP 메세지 포함
        - 출발지 IP, PORT
        - 목적지 IP, PORT
        - 전송 데이터 ( HTTP 요청 메세지 )
    3. 구글 서버에 전송

**요청을 받은 구글 서버**

1. 받은 메세지에서 TCP/IP 패킷를 해체하여 포트 정보와 HTTP 메세지를 분리
2. 쿼리 실행
3. HTTP 응답 메세지 생성
    ```
    HTTP/1.1 200 OK
    Content-Type: text/html;charset=UTF-8
    Content-Length: 3423
    <html>
        <body>...</body>
    </html>
    ```
4. TCP/IP 패킷 생성 + HTTP 메세지 포함
5. 클라이언트에 전송

### HTTP ( HyperText Transfer Protocol )
- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML (API)
- 거의 모든 형태의 데이터 전송 가능
- 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용

**역사**
- HTTP/0.9 1991년: GET 메서드만 지원, HTTP 헤더X
- HTTP/1.0 1996년: 메서드, 헤더 추가
- HTTP/1.1 1997년: 가장 많이 사용, 우리에게 가장 중요한 버전
    - RFC2068 (1997) -> RFC2616 (1999) -> RFC7230~7235 (2014)
- HTTP/2 2015년: 성능 개선
- HTTP/3 진행중: TCP 대신에 UDP 사용, 성능 개선

**기반 프로토콜**
- TCP: HTTP/1.1, HTTP/2
- UDP: HTTP/3
- 현재 HTTP/1.1 주로 사용
    - HTTP/2, HTTP/3 도 점점 증가

**HTTP**
- 클라이언트 서버 구조
- 무상태 프로토콜(스테이스리스), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

### 클라이언트 서버 구조
- Request Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답을 대기
- 서버는 요청에 대한 결과를 만들어서 응답

### 무상태 프로토콜
#### 스테이트리스 ( Stateless )
- 서버가 클라이언트의 상태를 보존하지 않는다
    - 장점: 서버 확장성 높음 ( 스케일 아웃 )
    - 단점: 클라이언트가 추가 데이터 전송

#### Stateful, Stateless 차이
- Stateful
    - 클라이언트와 서버가 1대1 대화
- Stateless
    - 클라이언트는 1 서버는 N 으로 대화
    - 서버가 바뀌는 앞서 했던 대화 내용을 모르기에 앞서 다른 서버와 했던 대화 내용까지 추가로 알려줘야 하기에 데이터 양이 많다

**정리**
- **상태 유지**: 중간에 다른 서버으로 바뀌면 안된다
    - 중간에 다른 서버으로 바뀔 때 상태 정보를 다른 서버에게 미리 알려줘야 한다
- **무상태**: 중간에 다른 서버로 바뀌어도 된다.
    - 갑자기 고객이 증가해도 서버을 대거 투입할 수 있다.
    - 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다
    - 무상태는 응답 서버를 쉽게 바꿀 수 있다
        - 무한한 서버 증설 가능
        - 스케일 아웃 ( 수평 확장에 유리 )

**중간 장애시**
- **상태 유지**
    - 다시 처음부터 진행
- **무상태**
    - 어차피 상태를 보관 하지 않기 때문에 다른 서버랑 연결해서 이어서 진행 가능

**실무 한계**
- 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다
- **무상태**
    - 로그인이 필요 없는 단순한 서비스 소개 화면
- **상태 유지**
    - 로그인
- 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지
- 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지
- **상태 유지는 최소한만 사용**

### 비 연결성 ( connectionless )
- HTTP는 기본이 연결을 유지하지 않는 모델
- 일반적으로 초 단위의 이하의 빠른 속도로 응답
- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이 하로 매우 작음
    - 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다
- 서버 자원을 매우 효율적으로 사용할 수 있음

**한계와 극복**
- TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함께 다운로드
- 지금은 HTTP 지속 연결 ( Persistent Connections ) 로 문제 해결
- HTTP/2, HTTP/3에서 더 많은 최적화

**서버 개발자들이 어려워하는 업무**
- 정말 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
    - 선착순 이벤트, 명절 KTX 예약, 학과 수업 등록
    - 저녁 6:00 선착순 1000명 치킨 할인 이벤트
        - 수만명 동시 요청

### HTTP 메시지
- HTTP 메시지에 모든 것을 전송
- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML
- 거의 모든 형태의 데이터 전송 가능
- 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용

#### HTTP 메시지 구조
- start-line ( 시작 라인 )
- header ( 헤더 )
- empty line ( 공백 라인 ) ( CRLF )
- message body
    - 요청 메세지도 body 본문을 가질 수 있음

##### 시작 라인
- start-line = request-line / status-line
    - request-line
        - method SP request-target SP HTTP-version CRLF
    - status-line
        - HTTP-version SP status-code SP reason-phrase CRLF

**요청 메시지**
```
GET /search?q=hello&hl=ko HTTP/1.1
Host: www.google.com
```
- HTTP 메서드 (GET: 조회)
- 요청 대상 (/search?q=hello&hl=ko)
- HTTP Version

**HTTP 메서드**
```
GET
```
- 종류
    - GET, POST, PUT, DELETE...
    - 서버가 수행해야 할 동작 지정
        - GET: 리소스 조회
        - POST: 요청 내역 처리

**요청 대상**
```
/search?q=hello&hl=ko
```
- absolute-path[?query] (절대경로[?쿼리])
- 절대경로= "/" 로 시작하는 경로
- 참고: *, http://...?x=y 와 같이 다른 유형의 경로지정 방법도 있다.

**HTTP 버전**
```
HTTP/1.1
```
- HTTP Version

**응답 메시지**
```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8 Content-Length: 3423
<html> <body>...</body>
</html>
```
- HTTP 버전
- HTTP 상태 코드: 요청 성공, 실패를 나타냄
    - 200: 성공
    - 400: 클라이언트 요청 오류
    - 500: 서버 내부 오류
- 이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글

#### HTTP 헤더
- header-field
    - field-name ":" OWS field-value OWS ( OWS: 띄어쓰기 허용 )
- field-name은 대소문자 구문 없음

**용도**
- HTTP 전송에 필요한 모든 부가정보
    - 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트 ( 브라우저 ) 정보, 서버 애플리케이션 정보, 캐시 관리 정보...
- 표준 헤더가 너무 많음
- 필요시 임의의 헤더 추가 가능

**요청**
```
Host: www.google.com
```

**응답**
```
Content-Type: text/html;charset=UTF-8
Content-Length: 3423
```

#### HTTP 메시지 바디
- 실제 전송할 데이터
- HTML 문서, 이미지, 영상, JSON 등등 byte 로 표현할 수 있는 모든 데이터 전송 가능

#### HTTP 정리
- HTTP는 단순하다
- HTTP 메시지도 매우 단순
- 크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술
- HTTP 메시지에 모든 것을 전송
- HTTP 역사 HTTP/1.1을 기준으로 학습 클라이언트 서버 구조
- 무상태 프로토콜 ( 스테이트리스 )
- HTTP 메시지
- 단순함, 확장 가능

### HTTP 메서드
- HTTP API를 만들어보자
- HTTP 메서드 - GET, POST
- HTTP 메서드 - PUT, PATCH, DELETE
- HTTP 메서드의 속성

#### API URI 설계

**API URI 고민**
- URI ( Uniform Resource Identifier )
- 리소스의 의미
    - 회원을 등록하라
        - 회원이 리소스 등록은 행위
    - 회원을 등록하고 수정하고 조회하는건 리소스가 아니다
- 회원이라는 개념 자체가 바로 리소스, 리소스를 어떻게 식별하는게 좋을까?
    - 회원을 등록하고 수정하고 조회하는 것을 모두 배제
    - 회원이라는 리소스만 식별
        - 회원 리소스를 URI에 매핑

**리소스와 행위을 분리**
- 가장 중요한 것은 리소스를 식별하는 것
- URI는 리소스만 식별
- 리소스와 해당 리소스를 대상으로 하는 행위을 분리
    - 리소스: 회원
    - 행위: 조회, 등록, 삭제, 변경
- 리소스는 명사, 행위는 동사
    - HTTP 메서드를 통해 행위를 구분

#### HTTP 메서드 종류
**주요 메서드**
- GET: 리소스 조회
- POST: 요청 데이터 처리, 주로 등록에 사용
- PUT: 리소스를 대체, 해당 리소스가 없으면 생성
- PATCH: 리소스 부분 변경
- DELETE: 리소스 삭제

**기타 메서드**
- HEAD: GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
- OPTIONS: 대상 리소스에 대한 통신 가능 옵션 ( 메서드 ) 을 설명 ( 주로 CORS에서 사용 )
- CONNECT: 대상 리소스로 식별되는 서버에 대한 터널을 설정
- TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

##### GET
```
GET /search?q=hello&hl=ko HTTP/1.1 Host: www.google.com
```
- 리소스 조회
- 서버에 전달하고 싶은 데이터는 query ( 쿼리 파라미터, 쿼리 스트링 ) 를 통해서 전달
- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음

1. 메시지 전달
2. 서버 도착
3. 응답 데이터

##### POST
```
POST /members HTTP/1.1
Content-Type: application/json

{
"username": "hello", "age": 20
}
```
- 요청 데이터 처리
- 메시지 바디를 통해 서버로 요청 데이터 전달
- 서버는 요청 데이터를 처리
    - 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다
- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용

1. 메세지 전달
2. 신규 리소스 생성
3. 응답 데이터

**POST 데이처 처리 종류**
- **스펙**
    - POST 메서드는 대상 리소스가 리소스의 고유 한 의미 체계에 따라 요청에 포함 된 표현을 처리하도록 요청 ( 구글 번역 )

- **예시**
1. HTML 양식에 입력 된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공
    - HTML FORM에 입력한 정보로 회원 가입, 주문 등에서 사용
2. 게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시
    - 게시판 글쓰기, 댓글 달기
3. 서버가 아직 식별하지 않은 새 리소스 생성
    - 신규 주문 생성
4. 기존 자원에 데이터 추가
    - 한 문서 끝에 내용 추가하기
- **정리**
    - 이 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 한다
        - 정해진 것이 없음

**POST 정리**
1. 새 리소스 생성 ( 등록 )
    - 서버가 아직 식별하지 않은 새 리소스 생성
2. 요청 데이터 처리
    - 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야 하는 경우
    - 주문에서 결제완료 - 배달시작 - 배달완료 처럼 단순히 값 변경을 넘어 프로세스의 상태가 변경되는 경우
    - POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음
    - POST /orders/{orderId}/start-delivery ( 컨트롤 URI )
3. 다른 메서드로 처리하기 애매한 경우
    - JSON으로 조회 데이터를 넘겨야 하는데, GET 메서드를 사용하기 어려운 경우
    - 애매하면 POST

##### PUT
```
PUT /members/100 HTTP/1.1
Content-Type: application/json

{
"username": "hello", "age": 20
}
```
- 리소스를 대체
    - 리소스가 있으면 대체
    - 리소스가 없으면 생성
    - 쉽게 이야기해서 덮어버림
- 클라이언트가 리소스를 식별
    - 클라이언트가 리소스 위치를 알고 URI 지정
    - POST와 차이점

**작동 원리**
- 기존에 리소스가 없는 경우
    - 신규 리소스 생성 후 저장
- 기존에 리소스가 있는 경우
    - 기존의 리소스를 대체
    - 기존의 리소스를 모두 지워버린 후 새로 작성
        - 기존에 age, name 컬럼이 있고 새로운 리소스에는 age 만 있다면 age 의 값만 바뀌는 것이 아니라 age, name 모두 삭제 후 age 값이 입력 되기 때문에 age 만 남아있게 된다
    
##### PATCH
```
PATCH /members/100 HTTP/1.1
Content-Type: application/json

{
"age": 50
}
```
- 리소스 부분 변경
    - 기존에 있는 데이터에 컬럼의 값만 바꾼다

##### DELETE
```
DELETE /members/100 HTTP/1.1
Host: localhost:8080
```
- 리소스 제거