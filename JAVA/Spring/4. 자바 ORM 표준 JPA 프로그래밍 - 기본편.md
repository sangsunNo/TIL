## Index

- [JPA](#jpa)
- [ORM](#orm)
- [객체를 자바 컬렉션처럼 DB 에 저장 할 수 없을까?](#객체를-자바-컬렉션처름-db-에-저장-할-수-없을까)
- [JPA 의 장점](#jpa-의-장점)
- [생산성 - JPA 와 CRUD](#생산성---jpa-와-crud)
- [유지보수](#유지보수)
- [JPA 와 패러다임의 불일치 해결](#jpa-와-패러다임의-불일치-해결)
- [JPA 의 성능 최적화](#jpa-의-성능-최적화)
---

### JPA
- Java Persistensce API
- 자바 진영의 [ORM](#orm) 기술 표준

**JPA 사용시**
- sql 쿼리 생성
- JDBC API 사용
- 패러다임 불일치 해결
---

### ORM
- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로 설계
- 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- ORM 프레임워크가 중간에서 매핑
- 대중적인 언어에는 대부분 ORM 기술이 존재
---

### 객체를 자바 컬렉션처름 DB 에 저장 할 수 없을까?
**객체지향과 관계형 데이터 베이스의 단점**

- 객체답게 모델링 할수록 매핑 작업만 늘어난다
- 탐색 가능 한 범위가 다르다.
    - 어떤 테이블들이 join 되어 있는지에 따라서 접근 할 수 있는 데이터가 정해진다.
    - JAVA 의 collection 이라면 이러한 문제가 발생하지 않는다.
        - 부모 데이터 타입을 통해 자식 데이터 까지 검색 가능하다.
- **==** 결과 값
    - 데이터 베이스에서 같은 id 를 통해 나온 유저라도 같은 내용을 가지고 있더라도 인스턴스가 다르다.
    - 리스트에서 나온 데이터 값은 같은 인스턴스를 참조하기 떄문에 같다. 
---

### JPA 의 장점
#### 생산성 - JPA 와 CRUD
- 저장: **jpa.persist(member)**
- 조회: Member member = **jpa.find(memberId)**
- 수정: **member.setName("변경할 이름")**
- 삭제: **jpa.remove()**

#### 유지보수
- 기존: 필드 변경시 모든 SQL 수정 
- JPA: 필드만 추가하면 됨, SQL은 JPA 가 처리

#### JPA 와 패러다임의 불일치 해결
1. JPA 와 상속
2. JPA 와 연관관계
3. JPA 와 객체 그래프 탐색
4. JPA 와 비교하기

#### JPA 의 성능 최적화
1. 1차 캐시와 동일성 ( identity ) 보장
    - 같은 트랜잭션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상
2. 트랜잭션을 지원하는 쓰기 지연 ( transactional write-behind )
    - 트랜잭션을 커밋 할 떄까지 INSERT SQL 을 모음
    - JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송
3. 지연 로딩 ( Lazy Loading )
    - 즉시 로딩: JOIN SQL 로 한 번에 객체까지 미리 조회
    - 지연 로딩: 객체가 실제 사용될 떄 로딩

