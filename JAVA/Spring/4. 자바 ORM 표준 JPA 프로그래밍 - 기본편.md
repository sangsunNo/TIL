## Index

- [JPA](#jpa)
- [ORM](#orm)
- [객체를 자바 컬렉션처럼 DB 에 저장 할 수 없을까?](#객체를-자바-컬렉션처름-db-에-저장-할-수-없을까)
- [JPA 의 장점](#jpa-의-장점)
- [생산성 - JPA 와 CRUD](#생산성---jpa-와-crud)
- [유지보수](#유지보수)
- [JPA 와 패러다임의 불일치 해결](#jpa-와-패러다임의-불일치-해결)
- [JPA 의 성능 최적화](#jpa-의-성능-최적화)
- [영속성 컨텍스트](#영속성-컨텍스트)
- [영속성 컨텍스트 ( 조회 )](#영속성-컨텍스트--조회)
- [영속성 컨텍스트의 동일성 보장](#영속성-컨텍스트의-동일성-보장)
- [영속성 컨텍스트 ( 쓰기 지연 )](#영속성-컨텍스트--쓰기-지연)
- [엔티티 수정 - 변경 감지 ( Dirty Checking )](#엔티티-수정---변경-감지--dirty-checking)
- [엔티티 삭제](#엔티티-삭제)

---

### JPA
- Java Persistensce API
- 자바 진영의 [ORM](#orm) 기술 표준

**JPA 사용시**
- sql 쿼리 생성
- JDBC API 사용
- 패러다임 불일치 해결

### ORM
- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로 설계
- 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- ORM 프레임워크가 중간에서 매핑
- 대중적인 언어에는 대부분 ORM 기술이 존재

### 객체를 자바 컬렉션처름 DB 에 저장 할 수 없을까?
**객체지향과 관계형 데이터 베이스의 단점**

- 객체답게 모델링 할수록 매핑 작업만 늘어난다
- 탐색 가능 한 범위가 다르다.
    - 어떤 테이블들이 join 되어 있는지에 따라서 접근 할 수 있는 데이터가 정해진다.
    - JAVA 의 collection 이라면 이러한 문제가 발생하지 않는다.
        - 부모 데이터 타입을 통해 자식 데이터 까지 검색 가능하다.
- **==** 결과 값
    - 데이터 베이스에서 같은 id 를 통해 나온 유저라도 같은 내용을 가지고 있더라도 인스턴스가 다르다.
    - 리스트에서 나온 데이터 값은 같은 인스턴스를 참조하기 떄문에 같다. 

### JPA 의 장점
#### 생산성 - JPA 와 CRUD
- 저장: **jpa.persist(member)**
   - [영속성 컨텍스트](#영속성-컨텍스트)에 저장
- 조회: Member member = **jpa.find(memberId)**
- 수정: **member.setName("변경할 이름")**
- 삭제: **jpa.remove()**
#### 유지보수
- 기존: 필드 변경시 모든 SQL 수정 
- JPA: 필드만 추가하면 됨, SQL은 JPA 가 처리

#### JPA 와 패러다임의 불일치 해결
1. JPA 와 상속
2. JPA 와 연관관계
3. JPA 와 객체 그래프 탐색
4. JPA 와 비교하기

#### JPA 의 성능 최적화
1. 1차 캐시와 동일성 ( identity ) 보장
    - 같은 트랜잭션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상
2. 트랜잭션을 지원하는 쓰기 지연 ( transactional write-behind )
    - 트랜잭션을 커밋 할 떄까지 INSERT SQL 을 모음
    - JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송
3. 지연 로딩 ( Lazy Loading )
    - 즉시 로딩: JOIN SQL 로 한 번에 객체까지 미리 조회
    - 지연 로딩: 객체가 실제 사용될 떄 로딩

### JPA 사용간에 주의점
- 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유
- 엔티티 메니저는 쓰레드간의 공유 ( X ) ( 사용후에 바로 버려줘야 한다 )
- JPA 의 모든 데이터 변경은 트랜잭션 안에서 실행해아 한다

### JPA 동작 순서
1. JPA 는 EntityManagerFactory 를 만들어야 한다.
    - 데이터베이스 당 하나씩 묶여서 동작
2. persistensce.xml 의 설정 파일의 name 을 읽어와서 만든다.
3. EntityManagerFactory 를 통해 EntityManager 를 생성한다.
4. 모든 작업은 생성된 EntityManager 를 통해서 해야 한다.
5. JPA 의 모든 데이터 변경은 트랜잭션 안에서 일어나야 한다.
6. 작업 완료후 commit 을 해줘야한다.
7. 생성한 EntityManager 를 닫아줘야 한다.
8. 생성한 EntityManagerFactory 를 닫아줘야 한다.

### JPQL
- JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
- SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원
- JPQL은 엔티티 객체를 대상으로 쿼리
    - 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리 
    - SELECT m FROM Member as m
- SQL은 데이터베이스 테이블을 대상으로 쿼리
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존X
- JPQL을 한마디로 정의하면 객체 지향 SQL

### 영속성 컨텍스트
**상태**
- 영속
    - 객체를 저장한 상태 ( 영속 )
    - em.persist(member);
- 비영속
    - 그저 객체를 생성하거나 한 관계 없는 상태
- 준영속
    - 현재 영속 상태에서 분리, 준영속 상태
- 삭제
    - 객체를 삭제한 상태 ( 삭제 )
    - remove(member);
&nbsp;
- 엔티티를 영구 저장하는 환경
- EntityManager.persist(entity);
    - 를 통해 DB 에 바로 저장되는 것이 아닌 영속성 컨텍스트에 저장이 된
- 트랜잭션을 commit 하는 순간 영속성 컨텍스트에 있는 쿼리가 DB 에 날아가게 된다

#### 영속성 컨텍스트 ( 조회 )
- 영속성 컨텍스트 내부에는 1차 캐시가 존재한다.
    - 1차 캐시에는 @Id - Entity - 스냅샷 으로 이루어져 있다.

**조회 순서**
- find 의 파라미터로 id 를 넘겨받고 해당 id 가 1차 캐시에 존재하는지 확인
    - 존재 한다면 해당하는 id 의 Entity 를 반환
    - 존재하지 않는다면 DB 에서 조회 후 1차 캐시에 저장한 다음 반환

- entityManager 같은 경우 데이터베이스 트랜잭션 단위로 만들고 트랜잭션이 끝날 때 같이 종료 시킨다
    - 고객의 요청이 하나 들어와서 비지니스가 끝나면 영속성 컨텍스트도 같이 지워진다
- 짧은 찰나의 순간에만 이득이 있다
- 여러명의 고객이 같이 사용하는 애플리케이션 전체에서 사용하는 캐시는 2차 캐시라고 한다 

#### 영속성 컨텍스트의 동일성 보장
- 두 개의 서로 다른 인스턴스가 같은 id 를 가진 entity 라면 동일성을 보장 받는다
    - a == b ( true )

#### 영속성 컨텍스트 ( 쓰기 지연 )
- persist 를 통해 영속성 컨텍스트의 1차 캐시에 저장될 떄에 **쓰기지연 저정소** 에 동시에 INSERT SQL 이 생성 된다
- 트랜잭션이 commit 될 때에 **flush** 를 통해 일괄 전송 후 DB 에 commit 이 된다

#### 엔티티 수정 - 변경 감지 ( Dirty Checking )
- JPA 에서는 데이터 값을 변경 할 때에 update 를 통한 변경이 필요 없다

**과정**
1. 영속성 엔티티 조회
    - find()
2. 수정
    - setname()

**원리**
- 1차 캐시 내부에는 @Id - entity - 스냅샷 으로 이루어져 있는다.
- 트랜잭션 커밋되는 시점에 flush 가 호출되며 모든 entity 들의 초기 스냅샷과 현재 스냅샷을 비교하여 달라진 부분이 있다면 쓰기 지연 SQL 저장소에 UPDATE SQL 을 생성하여 flush 해준다
- DB 에 전송된 쿼리들이 commit 되며 마무리 된다
&nbsp;
- flush() - 엔티티의 스냅샷 비교 - UPDATE SQL 생성 - flush - commit

#### 엔티티 삭제
- 대상 엔티티 조회 - 삭제
    - 엔티티 수정과 같은 과정을 거친다