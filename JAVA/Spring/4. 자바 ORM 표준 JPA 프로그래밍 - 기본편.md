## Index

- [JPA](#jpa)
- [ORM](#orm)
- [객체를 자바 컬렉션처럼 D에 저장 할 수 없을까?](#객체를-자바-컬렉션처름-db-에-저장-할-수-없을까)
- [JPA 의 장점](#jpa-의-장점)
- [생산성 - JPA 와 CRUD](#생산성---jpa-와-crud)
- [유지보수](#유지보수)
- [JPA 와 패러다임의 불일치 해결](#jpa-와-패러다임의-불일치-해결)
- [JPA 의 성능 최적화](#jpa-의-성능-최적화)
- [영속성 컨텍스트](#영속성-컨텍스트)
- [영속성 컨텍스트 ( 조회 )](#영속성-컨텍스트--조회)
- [영속성 컨텍스트의 동일성 보장](#영속성-컨텍스트의-동일성-보장)
- [영속성 컨텍스트 ( 쓰기 지연 )](#영속성-컨텍스트--쓰기-지연)
- [엔티티 수정 - 변경 감지 ( Dirty Checking )](#엔티티-수정---변경-감지--dirty-checking)
- [엔티티 삭제](#엔티티-삭제)
- [플러시](#플러시)
- [준영속 상태](#준영속-상태)
- [엔티티 매핑](#엔티티-매핑)
- [@Entity](#entity)
- [Table](#table)
- [데이터베이스 스키마 자동 생성](#데이터베이스-스키마-자동-생성)
- [DDL 생성 기능](#ddl-생성-기능)
- [필드와 컬럼 매핑](#필드와-컬럼-매핑)
- [@Column](#column)
- [@Enumerated](#enumerated)
- [Temporal](#temporal)
- [Lob](#lob)
- [Transient](#transient)
- [기본키 매핑](#기본키-매핑)
- [기본키 매핑 방법](#기본키-매핑-방법)
- [IDENTITY 전략](#identity-전략)
- [SEQUENCE 전략](#sequence-전략)
- [TABLE 전략](#table-전략)
- [권장하는 식별자 전략](#권장하는-식별자-전략)
- [전략별 INSERT 시에 ID 값 설정](#전략별-insert-시에-id-값-설정)
- [연관관계 매핑](#연관관계-매핑)
- [연관관계 매핑이 필요한 이유](#연관관계-매핑이-필요한-이유)
- [단방향 연관관계](#단방향-연관관계)
- [양방향 연관관계](#양방향-연관관계)
- [연관관계의 주인 ( Owner )](#연관관계의-주인--owner)
- [양방향 매핑시 가장 많이 하는 실수](#양방향-매핑시-가장-많이-하는-실수)
- [양방향 매핑 정리](#양방향-매핑-정리)
- [다양한 연관관계 매핑](#다양한-연관관계-매핑)
- [다대일](#다대일)
- [일대다](#일대다)
- [일대일](#일대일)
---




### JPA
- Java Persistensce API
- 자바 진영의 [ORM](#orm) 기술 표준
**JPA 사용시**
- sql 쿼리 생성
- JDBC API 사용
- 패러다임 불일치 해결
엔티티 매핑
### ORM
- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로 설계
- 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- ORM 프레임워크가 중간에서 매핑
- 대중적인 언어에는 대부분 ORM 기술이 존재

### 객체를 자바 컬렉션처름 DB 에 저장 할 수 없을까?
**객체지향과 관계형 데이터 베이스의 단점**

- 객체답게 모델링 할수록 매핑 작업만 늘어난다
- 탐색 가능 한 범위가 다르다.
    - 어떤 테이블들이 join 되어 있는지에 따라서 접근 할 수 있는 데이터가 정해진다.
    - JAVA 의 collection 이라면 이러한 문제가 발생하지 않는다.
        - 부모 데이터 타입을 통해 자식 데이터 까지 검색 가능하다.
- **==** 결과 값
    - 데이터 베이스에서 같은 id 를 통해 나온 유저라도 같은 내용을 가지고 있더라도 인스턴스가 다르다.
    - 리스트에서 나온 데이터 값은 같은 인스턴스를 참조하기 떄문에 같다. 

### JPA 의 장점
#### 생산성 - JPA 와 CRUD
- 저장: **jpa.persist(member)**
   - [영속성 컨텍스트](#영속성-컨텍스트)에 저장
- 조회: Member member = **jpa.find(memberId)**
- 수정: **member.setName("변경할 이름")**
- 삭제: **jpa.remove()**
#### 유지보수
- 기존: 필드 변경시 모든 SQL 수정 
- JPA: 필드만 추가하면 됨, SQL은 JPA 가 처리

#### JPA 와 패러다임의 불일치 해결
1. JPA 와 상속
2. JPA 와 연관관계
3. JPA 와 객체 그래프 탐색
4. JPA 와 비교하기

#### JPA 의 성능 최적화
1. 1차 캐시와 동일성 ( identity ) 보장
    - 같은 트랜잭션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상
2. 트랜잭션을 지원하는 쓰기 지연 ( transactional write-behind )
    - 트랜잭션을 커밋 할 떄까지 INSERT SQL 을 모음
    - JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송
3. 지연 로딩 ( Lazy Loading )
    - 즉시 로딩: JOIN SQL 로 한 번에 객체까지 미리 조회
    - 지연 로딩: 객체가 실제 사용될 떄 로딩

### JPA 사용간에 주의점
- 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유
- 엔티티 메니저는 쓰레드간의 공유 ( X ) ( 사용후에 바로 버려줘야 한다 )
- JPA 의 모든 데이터 변경은 트랜잭션 안에서 실행해아 한다

### JPA 동작 순서
1. JPA 는 EntityManagerFactory 를 만들어야 한다.
    - 데이터베이스 당 하나씩 묶여서 동작
2. persistensce.xml 의 설정 파일의 name 을 읽어와서 만든다.
3. EntityManagerFactory 를 통해 EntityManager 를 생성한다.
4. 모든 작업은 생성된 EntityManager 를 통해서 해야 한다.
5. JPA 의 모든 데이터 변경은 트랜잭션 안에서 일어나야 한다.
6. 작업 완료후 commit 을 해줘야한다.
7. 생성한 EntityManager 를 닫아줘야 한다.
8. 생성한 EntityManagerFactory 를 닫아줘야 한다.

### JPQL
- JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
- SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원
- JPQL은 엔티티 객체를 대상으로 쿼리
    - 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리 
    - SELECT m FROM Member as m
- SQL은 데이터베이스 테이블을 대상으로 쿼리
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존X
- JPQL을 한마디로 정의하면 객체 지향 SQL

### 영속성 컨텍스트
**상태**
- 영속
    - 객체를 저장한 상태 ( 영속 )
    - em.persist(member);
- 비영속
    - 그저 객체를 생성하거나 한 관계 없는 상태
- 준영속
    - 현재 영속 상태에서 분리, 준영속 상태
- 삭제
    - 객체를 삭제한 상태 ( 삭제 )
    - remove(member);
&nbsp;
- 엔티티를 영구 저장하는 환경
- EntityManager.persist(entity);
    - 를 통해 DB 에 바로 저장되는 것이 아닌 영속성 컨텍스트에 저장이 된
- 트랜잭션을 commit 하는 순간 영속성 컨텍스트에 있는 쿼리가 DB 에 날아가게 된다

#### 영속성 컨텍스트 ( 조회 )
- 영속성 컨텍스트 내부에는 1차 캐시가 존재한다.
    - 1차 캐시에는 @Id - Entity - 스냅샷 으로 이루어져 있다.

**조회 순서**
- find 의 파라미터로 id 를 넘겨받고 해당 id 가 1차 캐시에 존재하는지 확인
    - 존재 한다면 해당하는 id 의 Entity 를 반환
    - 존재하지 않는다면 DB 에서 조회 후 1차 캐시에 저장한 다음 반환

- entityManager 같은 경우 데이터베이스 트랜잭션 단위로 만들고 트랜잭션이 끝날 때 같이 종료 시킨다
    - 고객의 요청이 하나 들어와서 비지니스가 끝나면 영속성 컨텍스트도 같이 지워진다
- 짧은 찰나의 순간에만 이득이 있다
- 여러명의 고객이 같이 사용하는 애플리케이션 전체에서 사용하는 캐시는 2차 캐시라고 한다 

#### 영속성 컨텍스트의 동일성 보장
- 두 개의 서로 다른 인스턴스가 같은 id 를 가진 entity 라면 동일성을 보장 받는다
    - a == b ( true )

#### 영속성 컨텍스트 ( 쓰기 지연 )
- persist 를 통해 영속성 컨텍스트의 1차 캐시에 저장될 떄에 **쓰기지연 저정소** 에 동시에 INSERT SQL 이 생성 된다
- 트랜잭션이 commit 될 때에 **flush** 를 통해 일괄 전송 후 DB 에 commit 이 된다

#### 엔티티 수정 - 변경 감지 ( Dirty Checking )
- JPA 에서는 데이터 값을 변경 할 때에 update 를 통한 변경이 필요 없다

**과정**
1. 영속성 엔티티 조회
    - find()
2. 수정
    - setname()

**원리**
- 1차 캐시 내부에는 @Id - entity - 스냅샷 으로 이루어져 있는다.
- 트랜잭션 커밋되는 시점에 flush 가 호출되며 모든 entity 들의 초기 스냅샷과 현재 스냅샷을 비교하여 달라진 부분이 있다면 쓰기 지연 SQL 저장소에 UPDATE SQL 을 생성하여 flush 해준다
- DB 에 전송된 쿼리들이 commit 되며 마무리 된다
&nbsp;
- flush() - 엔티티의 스냅샷 비교 - UPDATE SQL 생성 - flush - commit

#### 엔티티 삭제
- 대상 엔티티 조회 - 삭제
    - 엔티티 수정과 같은 과정을 거친다

### 플러시
- 영속성 컨텍스트의 변경 사항을 데이터 베이스에 반영
- 플러시를 통해 DB 에 반영이 되는 것일 뿐 영속성 컨텍스트를 비우지 않는다
- 트랜잭션이라는 작업 단위가 있기 때문에 커밋 직전에만 동기화 시켜주면 된다

**플러시 발생**
- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터 베이스에 전송 ( 등록, 수정, 삭제 쿼리 )

**영속성 컨텍스트를 플러시하는 방법**
- em.flush() = 직접 호출
- 트랜잭선 커밋 = 플러시 자동 호출
- JPQL 쿼리 실행 = 플러시 자동 호출
    - JPQL 을 통해 확인하려 했던 내용들이 앞선 쿼리들이 DB 에 반영이 되지 않아 틀린 결과값을 줄 수 있기 떄문에 자동으로 호출된다

### 준영속 상태
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리 ( detached )
- 영속성 컨텍스트가 제공하는 기능을 사용히지 못한다
- 영속성 상태였을 때에 데이터의 변경이 있었더라도 준영속 상태로 변한 후 commit 이 일어나더라도 변환된게 반영이 되지 않는다

**준영속 상태로 만드는 법**
- em.detach(entity)
    - 특정 엔티티만 준영속 상태로 전환
- em.clear()
    - 영속성 컨텍스트를 완전히 초기화
- em.close()
    - 영속성 컨텍스트를 종료

## 엔티티 매핑
- 객체와 테이블 매핑: [@Entity](#entity), @Table
- 필드와 컬럼 매핑: @Column
- 기본 키 매핑: @Id
- 연관관계 매핑: @ManyToOne, @JoinColumn

### @Entity
- @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다. 
- JPA를 사용해서 테이블과 매핑할 클래스는 **@Entity** 필수

**주의**
- 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자)
- final 클래스, enum, interface, inner 클래스 사용 불가
- 저장할 필드에 final 사용 불가

**속성**
- name
    - JPA에서 사용할 엔티티 이름을 지정한다
    - 기본값: 클래스 이름을 그대로 사용(예: Member)
    - 같은 클래스 이름이 없으면 가급적 기본값을 사용한다


### Table
- @Table은 엔티티와 매핑할 테이블 지정

**속성**
- name
    - 매핑할 테이블 이름 지정
    - 기본 값으로 엔티티 이름을 사용
    - 동일한 이름을 가지고 있거나, 이름에 대한 규칙이 있는 경우 사용

### 데이터베이스 스키마 자동 생성
- DDL을 애플리케이션 실행 시점에 자동 생성 - 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성

**속성**
- hibernate.hbm2ddl.auto

|옵션|설명|
|:---:|:---:|
|create|기존테이블 삭제 후 다시 생성 (DROP + CREATE)|
|create-drop|create와 같으나 종료시점에 테이블 DROP|
|update|변경분만 반영(운영DB에는 사용하면 안됨)|
|validate|엔티티와 테이블이 정상 매핑되었는지만 확인|
|none|없음|

**주의**
- **운영 장비에는 절대 create, create-drop, update 사용하면 안된다**
- 개발 초기을 제외한 테스트 서버, 스테이징과 운영 서버에는 validate 또는 none 을 사용하여 발생할 수 있는 사고에 대해 원천 제거하는 것이 좋다

#### DDL 생성 기능
- 제약 조건 추가: 회원 이름은 **필수**, 10자 초과 불가
    - @Column(nullable = false, length = 10)
- DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고, JPA의 실행 로직에는 영향을 주지 않는다

### 필드와 컬럼 매핑
|어노테이션|설명|
|:--:|:--:|
|@Column|컬럼 매핑|
|@Temporal|날짜 타입 매핑|
|@Enumerated1|enum 타입 매핑|
|@Lob|BLOB, CLOB 매핑|
|@Transient|특정 필드를 컬럼에 매핑하지 않음 (매핑 무시 )|

#### @Column
<img src="../../PIC/JAVA Spring/4. 자바 ORM 표준 JPA 프로그래밍 - 기본편/1. @Column.png">

#### @Enumerated
- 자바 enum 타입을 매핑할 때 사용
- ORDINAL 선택 할 경우 enum 내부에서 순서가 바뀔 경우 돌이킬 수 없는 상황 발생
- **ORDINAL 사용 절대 금지**

|속성|설명|기본 값|
|:--:|:--:|:--:|
|value|- EnumType.ORDINAL: enum 순서를 데이터베이스에 저장 <br> - EnumType.STRING: enum 이름을 데이터베이스에 저장|EnumType.ORDINAL|

#### Temporal
- 날짜 타입(java.util.Date, java.util.Calendar)을 매핑할 때 사용

**참고**
- LocalDate, LocalDateTime을 사용할 때는 생략 가능(최신 하이버네이트 지원)
 
|속성|설명|기본 값|
|:--:|:--:|:--:|
|value|- **TemporalType.DATE:** 날짜, 데이터베이스 date 타입과 매핑 (예: 2013–10–11) <br> - **TemporalType.TIME:** 시간, 데이터베이스 time 타입과 매핑 (예: 11:11:11) <br> - **TemporalType.TIMESTAMP:** 날짜와 시간, 데이터베이스 timestamp 타입과 매핑 (예: 2013–10–11 11:11:11)||

#### Lob
- 데이터베이스 BLOB, CLOB 타입과 매핑
- @Lob에는 지정할 수 있는 속성이 없다.
- 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑
    - CLOB: String, char[], java.sql.CLOB
    - BLOB: byte[], java.sql. BLOB

#### Transient
- 필드 매핑을 하지 않는다 선언
- DB 에 저장, 조회 불가능
- 주로 메모리에 무언가 저장하고 싶을 때 사용

@Transient
private Integer temp;

### 기본키 매핑

**기본키 매핑 어노테이션**
- Id
- GeneratedValue

#### 기본키 매핑 방법
- 직접 할당: @Id 만 사용
- 자동 생성: @GeneratedValue
    - **IDENTITY**: 데이터베이스에 위임, MYSQL
    - **SEQUENCE**: 데이터베이스 시퀀스 오브젝트 사용, ORACLE
        - @SequenceGenerator 필요
    - **TABLE**: 키 생성용 테이블 사용, 모든 DB에서 사용
        - @TableGenerator 필요
    - **AUTO**: 방언에 따라 자동 지정, 기본값

##### IDENTITY 전략
- 기본 키 생성을 데이터베이스에 위임
- 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용         (예: MySQL의 AUTO_ INCREMENT)
- JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행
- AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행 한 이후에 ID 값을 알 수 있음
- IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행하고 DB에서 식별자를 조회

```JAVA
@GeneratedValue(strategy = GenerationType.IDENTITY)
```

##### SEQUENCE 전략
- 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트(예: 오라클 시퀀스)
- 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용

```JAVA
@GeneratedValue(strategy = GenerationType.SEQUENCE)
```

- 기본 SEQUENCE 가 아닌 테이블 마다 관리를 원한다면 @SequenceGenerator 를 통해 설정 후 @GeneratedValue 에 추가 해주면 된다

```JAVA
@Entity
@SequenceGenerator(
name = “MEMBER_SEQ_GENERATOR",
sequenceName = “MEMBER_SEQ", //매핑할 데이터베이스 시퀀스 이름
initialValue = 1, allocationSize = 1)
public class Member {
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE,
                generator = "MEMBER_SEQ_GENERATOR")
private Long id;
```

##### TABLE 전략
- 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉 내내는 전략
- 장점: 모든 데이터베이스에 적용 가능
- 단점: 성능

#### 권장하는 식별자 전략
- 기본 키 제약 조건: null 아님, 유일, 변하면 안된다
- 미래까지 이 조건을 만족하는 자연키는 찾기 어렵다. 대리키(대체키)를 사용하자
- 예를 들어 주민등록번호도 기본 키로 적절하기 않다
- 권장: Long형 + 대체키 + 키 생성전략 사용

##### 전략별 INSERT 시에 ID 값 설정
- 영속성 컨텍스트의 1차 캐시에 저장하기 위해서는 ID 값이 필요, 이때에 전략별 해결 방법
- **IDENTITY**
    - commit 이 아닌 persist 에 insert 를 실행하여 DB에 저장 후 id 값 반환
- **SEQUENCE**
    - DB 에 현재 SEQUENCE 의 다음 번호를 요청하여 영속성 컨텍스트에 저장

### 연관관계 매핑
- 객체와 테이블 연관관계의 차이를 이해
- 객체의 참조와 테이블의 외래 키를 매핑

**용어**
- **방향(Direction)**: 단방향, 양방향
- **다중성(Multiplicity)**: 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M) 이해
- **연관관계의 주인(Owner)**: 객체 양방향 연관관계는 관리 주인 이 필요

#### 연관관계 매핑이 필요한 이유
- 객체를 테이블에 맞추어 데이터 중심으로 모델링하면, 협력 관계를 만들 수 없다
    - 테이블은 외래키로 조인을 사용해서 연관된 테이블을 찾는다
    - 객체는 참조를 사용해서 연관된 객체를 찾는다
    - 테이블과 객체 사이에는 이런 큰 간격이 있다
- 데이터 베이스에서는 외래키와 join 을 통해 다른 테이블의 값을 가져 올 수 있다
- 객체에서는 다른 테이블의 키를 갖고 그 키를 통해 다른 테이블 객체에 접근하여 값을 찾아와야 한다 

#### 단방향 연관관계
- 기존 테이블은 외래키를 매개체로 join 을 통해 양쪽의 테이블에 접근이 가능하다
- 단방향 연관관계는 말 그대로 한쪽에서만 쉽게 접근이 가능한 방법이다

**사용법**
- Member 테이블에서 Team 테이블과 단방향 연관 관계를 맺는 경우
- 팀 내부에 멤버들이 있다
    - 다수의 멤버들이 한 팀 안에 존재
    - n 대 1 관계  
&nbsp;
- @ManyToOne
    - 다수인 Member = Many
    - 하나인 Team = One
- @JoinColumn(name = "TEAM_ID")
    - 데이터 베이스에서 join 을 할 때 사용하는 외래키 설정
- private Team team;
    - Member 객체와 함께 join 할 객체

```JAVA
@Entity
public class Member {
    ...
    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
```

#### 양방향 연관관계
- 한쪽에서만 접근이 가능한 단방향 연관 관계와 달리 데이터 베이스와 같이 양 방향에서 서로 접근이 가능한 방법
- 데이터 베이스의 테이블은 외래키를 통한 1개의 연관 관계를 맺고 있으나 양방향 연관 관계는 2개의 연관 관계를 맺고 있다
    - 사실 객체 서로가 서로에게 단방향 연관 관계를 맺고 있다
&nbsp;
- @OneToMany(mappedBy = "team")
    - 하나인 Team과 다수인 Member 를 나타내 준다
- (mappedBy = "team")
    - 양방향에서는 먼저 연관 관계를 요청한 쪽과 매핑 된 위치를 표기
- List<Member> members = new ArrayList<Member>();
    - 초기화를 통해서 NULL 방지

```JAVA
@Entity
public class Team {
    ...
    @OneToMany(mappedBy = "team")
    List<Member> members = new ArrayList<Member>();
```

#### 연관관계의 주인 ( Owner )
- 양방향 매핑에서 서로 데이터를 변경 할 수 있기에 생기는 불상사를 방지하기 위해서 연관관계의 주인을 설정해 주어야 한다.

**주인 선정 기준**
- n 과 1 이 있다면 기본적으로 n 에 설정하는게 바람직 하다

**양방향 매핑 규칙**
- 객체의 두 관계중 하나를 연관관계의 주인으로 지정
- 연관 관계의 주인만이 외래키를 관리 ( 등록, 수정 )
- 주인이 아닌 쪽은 읽기만 가능
- 주인은 키를 관리한다
    - @JoinColumn(name = "키 이름")
- 주인은 mappedBy 속성을 사용하지 않는다
- 주인이 아니면 mappedBy 속성으로 주인 지정한다
    - 단어에서 볼 수 있듯 수동적으로 관리를 당하는 상태이다

#### 양방향 매핑시 가장 많이 하는 실수
- 연관관계의 주인에 값을 입력하지 않음
    - 연관관계의 주인만 값이 입력이 가능
    - 연관관계의 주인이 아닌 경우에는 읽기만 가능
- **양쪽 모두 입력 필수**
    - 양방향 연관관계 매핑시 JOIN 과 같은 논리이기 때문에 한쪽에 값을 입력하여도 자동으로 반대편에도 추가가 된다
    - 하지만 이는 객체지향스럽지 않으며, flush 이전에는 데이터베이스에 저장되지 않기 때 비정상적인 작동을 불러일으킬 수 있다
- 편의 메서드 생성
    - 양쪽 모두 입력시 빠뜨리는 경우가 있을 수 있으니 메서드를 통해 자동으로 입력이 될 수 있게 설정
- 무한 루프 조심
    - 서로가 서로를 호출하여 무한 루프에 빠질 수 있다
        - toString(), lombok, JSON 생성 라이브러리

#### 양방향 매핑 정리
- 단방향 매핑만으로 이미 연관관계 매핑은 완료
- 양방향 매핑은 반대 방향으로 조회 ( 객체 그래프 탐색 ) 기능이 추가된 것 뿐
- 단방향 매핑을 한 후 양방향 매핑은 필요할 때 추가하면 됨 ( 테이블에 영향을 주지 않음 )
- JPQL 에서 역방향으로 탐색할 일이 많음

**연관관계 주인을 정하는 기준**
- 비지니스 로직을 기준으로 연관관계 주인을 선택하면 안됨
- 연관관계 주인은 외래키의 위치를 기준으로 정해야함

### 다양한 연관관계 매핑

**연관관계 매핑시 고려사항**
1. 다중성
2. 단방향, 양방향
3. 연관관계 주인

**다중성**
- 다대일: @ManyToOne
- 일대다: @OneToMany
- 일대일: @OneToOne
- 다 대다: @ManyToMany

**단방향, 양방향**
- 테이블
    - 외래 키 하나로 양쪽 조인 가능
    - 사실 방향이라는 개념이 없음
- 객체
    - 참조용 필드가 있는 쪽으로만 참조 가능
    - 한쪽만 참조하면 단방향
    - 양쪽이 서로 참조하면 양방향

**연관관계의 주인**
- 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
- 객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데
- 객체 양방향 관계는 참조가 2군데 있음. 둘중 테이블의 외래 키 를 관리할 곳을 지정해야함
- 연관관계의 주인: 외래 키를 관리하는 참조
- 주인의 반대편: 외래 키에 영향을 주지 않음, 단순 조회만 가능

#### 다대일
**단방향**
- 가장 많이 사용하는 연관관계

**양방향**
- 외래 키가 있는 쪽이 연관관계의 주인
- 양쪽을 서로 참조하도록 개발

#### 일대다
**단방향**
- 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인
- 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있음
- 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하 는 특이한 구조
- @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함)
    - 주인인 1쪽에서 @JoinColumn 을 입력하지만 다른쪽에서 FK 를 보관하기 때문에 본인 기본키를 입력해야 한다 ( @JoinColumn(name= "본인 PK") )
- 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자
&nbsp;
    **단점**
- 엔티티가 관리하는 외래 키가 다른 테이블에 있음
- 연관관계 관리를 위해 추가로 UPDATE SQL 실행

**양방향**
- 이런 매핑은 공식적으로 존재X @JoinColumn(insertable=false, updatable=false)
- 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법
- 다대일 양방향을 사용하자

#### 일대일
- 일대일 관계는 반대도 일대일
- 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
    - 주 테이블에 외래 키
    - 대상 테이블에 외래 키
- 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

**단방향**
- 다대일(@ManyToOne) 단방향 매핑과 유사
- 주 테이블이 아닌 대상 테이블에 외래키가 있는 경우 JPA 를지원하지 않는다

**양방향**
- 다대일 양방향 매핑 처럼 외래 키가 있는 곳이 연관관계의 주인 
- 반대편은 mappedBy 적용

**주 테이블의 외래키**
- 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
- 객체지향 개발자 선호
- JPA 매핑 편리
- 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
- 단점: 값이 없으면 외래 키에 null 허용

**대상 테이블의 외래키**
- 대상 테이블에 외래 키가 존재
- 전통적인 데이터베이스 개발자 선호
- 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
- 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩

#### 다대다
- 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능
- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현 불가능
- 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야 한다
&nbsp;
- @ManyToMany 사용
- @JoinTable로 연결 테이블 지정 ( 기존의 @JoinColumn X )
    - 매핑을 위한 테이블을 만든다
- 다대다 매핑: 단방향, 양방향 가능

**다대다 매핑의 한계**
- 편리해 보이지만 실무에서 사용하지 않음
- 연결 테이블이 단순히 연결만 하는데서 끝나는게 아님
    - 매핑 정보 추가에서 끝이나며 추가가 불가능
    - 주문시간, 수량 같은 데이터와 같은 column 추가가 불가능
- 중간 테이블에 의해서 예상치 못한 쿼리가 나옴 

**다대다 한계 극복**
- 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)
- @ManyToMany -> @OneToMany, @ManyToOne

### 상속관계 매핑
- 관계형 데이터베이스는 상속 관계가 없다
- 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다
- 상속관계 매핑: 객체의 상속 구조와 DB의 슈퍼타입 서브타입 관계를 매핑

**슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법**
- 각각 테이블로 변환 -> 조인 전략
- 통합 테이블로 변환 -> 단일 테이블 전략
- 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 생성 전략

**주요 어노테이션**
- @Inheritance(strategy=InheritanceType.XXX)
    - 어떤 전략인지 설정
        - JOINED: 조인 전략
        - SINGLE_TABLE: 단일 테이블 전략
        - TABLE_PER_CLASS: 구현 클래스마다 테이블 전략 
- @DiscriminatorColumn(name=“DTYPE”)
    - 상위 클래스에서 추가되는 데이터가, 어떤 하위 클래스인지 명시 해주는 column 삽입
- @DiscriminatorValue(“XXX”)
    - @DiscriminatorCoumn 에 입력되는 값을 지정가능
    - 디폴트 값은 클래스명

#### 조인 전략
**장점**
- 테이블 정규화
- 외래 키 참조 무결성 제약조건 활용가능
- 저장공간 효율화

**단점**
- 조회시 조인을 많이 사용 ,성능저하
- 조회 쿼리가 복잡함
- 데이터 저장시 INSERT SQL 2번 호출

#### 단일 테이블 전략
**장점**
- 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
- 조회 쿼리가 단순함
**단점**
- 자식 엔티티가 매핑한 컬럼은 모두 null 허용
- 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 느려질 수 있다.

#### 구현 클래스마다 테이블 전략
- 이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 비추천

**장점**
- 서브 타입을 명확하게 구분해서 처리할 때 효과적
- not null 제약조건 사용 가능

**단점**
- 여러 자식 테이블을 함께 조회할 때 성능이 느림 ( UNION SQL 필요 )
- 자식 테이블을 통합해서 쿼리하기 어려움