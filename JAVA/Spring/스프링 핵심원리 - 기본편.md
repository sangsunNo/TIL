## Index

- [스프링 생태계](#스프링-생태계)
- [스프링 프레임워크](#스프링-프레임워크)
- [스프링 부트](#스프링-부트)
- [스프링의 핵심](#스프링의-핵심)
- [객체지향 프로그래밍](#객체지향-프로그래밍)
- [좋은 객체 지향 설계의 5가지 원칙 (SOLID)](#좋은-객체-지향-설계의-5가지-원칙-solid)
- [관심사의 분리 ( DIP )](#관심사의-분리--dip)
- [AppConfig](#appconfig)
- [스프링 빈 설정 메타 정보](#스프링-빈-설정-메타-정보)
- [싱글톤 패턴 ( singleton )](#싱글톤-패턴--singleton)
- [싱글톤 패턴의 단점](#싱글톤-패턴의-단점)
- [싱글톤 패턴의 주의점](#싱글톤-패턴의-주의점)
- [@Configuration과 바이트코드](#configuration과-바이트코드)
- [@ComponentScan, @Component, @Autowired](#componentscan-component-autowired)
- [@ComponentScan 제외 설정](#componentscan-제외-설정)
- [@ComponentScan 시작 지점 설정](#componentscan-시작-지점-설정)
- [@ComponentScan 필터 설정](#componentscan-필터-설정)
- [어노테이션 생성](#어노테이션-생성)
]
---

### 스프링 생태계

- 필수
    - [스프링 프레임워크](#스프링-프레임워크): 스프링의 핵심
    - [스프링 부트](#스프링-부트): 여러 스프링 기술들을 편리하게 사용할 수 있게 도와준다.
- 선택
    - 스프링 데이터: 데이터 베이스, CRUD 를 편리하게 도와준다. (JPA)
    - 스프링 세션: 세션 기능을 편리하게 사용할 수 있게 도와준다.
    - 스프링 시큐리티: 보안 관련
    - 스프링 Rest Docs: api 문서와 테스트를 엮어서 api 문서화를 편하게 도와준다.
    - 스프링 배치: 엄청난 양의 데이터가 들어올 시 한 번에 처리하는게 아니라 몇 백 ~ 천 건의 데이터를 가져와 처리하는 것을 배치 처리라 하는데 이를 도와준다. 
    - 스프링 클라우드: 클라우드 기술에 특화된 기술

#### 스프링 프레임워크
- **핵심 기술**: 스프링 DI 컨테이너, AOP, 이벤트, 기타
- **웹 기술**: 스프링 MVC, 스프링 WebFlux
- **데이터 접근 기술**: 트랜잭션, JDBC, ORM 지원, XML 지원
- **기술 통합**: 캐시, 이메일, 원격접근, 스케줄링
- **테스트**: 스프링 기반 테스트 지원
- **언어**: 코틀린, 그루비
- 최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용

#### 스프링 부트
- **스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용**
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
- 스프링과 3rd party(외부) 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

### 스프링의 핵심
- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - 객체 지향 언어
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

#### 객체지향 프로그래밍
- 좋은 객체지향 프로그래밍은 객체를 역할과 구현을 명확히 분리시킨다.

- 객체
    - 역할: Interface
    - 구현: Interface 를 상속받아 구현
- 원활한 프로그래밍을 위해서는 프로그램이 구동하는데 필수적으로 요구되는 뼈와 살, 근육과 같은 부위를 미리 Interface 를 통해 선언을 해 둔다면 이를 상속하는 입장에서는 필수적으로 override 해야하기 때문에 수정, 교체에 매우 용이하다.
    - 서버의 DB를 컴퓨터의 메모리에서 JDBC로 교체를 원할 때에 DB의 Interface를 override를 통해 메모리 기반의 저장에서 JDBC로 대체 할 수 있다.
    - 시계의 톱니바퀴를 교체하는데에 interface 에서 직경과 두꼐를 설정해 두면 이를 만족하는 톱니바퀴는 기존의 톱니바퀴를 대체 할 수 있다.

### 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

- SRP: 단일 책임 원칙(Single responsibility principle)
- OCP: 개방-폐쇄 원칙 (Open/closed principle)
- LSP: 리스코프 치환 원칙 (Liskov substitution principle)
- ISP: 인터페이스 분리 원칙 (Interface segregation principle)
- DIP: 의존관계 역전 원칙 (Dependency inversion principle)


> **SRP: 단일 책임 원칙(Single responsibility principle)**
>> 한 클래스는 하나의 책임만 가져야 한다.
>>
>> 하나의 책임이라는 것은 모호하다.
>>> 클 수 있고, 작을 수 있다.
>>> 문맥과 상황에 따라 다르다.
>>
>> 중요한 기준은 변경이다.
>> 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
>>
>> 예) UI 변경, 객체의 생성과 사용을 분리

> **OCP: 개방-폐쇄 원칙 (Open/closed principle)**
>> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
>>
>> 다형성을 통해 Interface로 형틀을 만들어 변경을 막고 구현을 통해 확장을 한다.
>> **문제점**
>>> DB를 메모리에서 JDBC 로 변경시 클라이언트 코드를 변경해야한다.
>>> 다형성만으로는 OCP 원칙을 지킬 수 없다.

> **LSP: 리스코프 치환 원칙 (Liskov substitution principle)**
>> 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
>>
>> 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위 한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요하다.
>>
>> 단순히 컴파일에 성공하는 것을 넘어서서 실행 방향까지 포함된 것이다.
>>> 자동차 엑셀 기능에 뒤로가는 기능을 넣는 것으로 느리더라도 앞으로 가야한다.

> **ISP: 인터페이스 분리 원칙 (Interface segregation principle)**
>> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
>>
>> 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
>> 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
>>
>> 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다.
>>
>> 인터페이스가 명확해지고, 대체 가능성이 높아진다.

> **DIP: 의존관계 역전 원칙 (Dependency inversion principle)**
>> 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙 을 따르는 방법 중 하나다.
>>> 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
>>>
>>> 역할(Interface)에 의존의 해야 변경에 용의하다. 구현된 구현체에 깊게 의존하고 있다면 변경시에 의존하는 부분의 대체로 인해 변경이 아주 어려워진다.
>>>
>> **문제점**
>>> DB의 Interface 에 의존하지만, 구현클래스 역시 의존한다.
>>>
>>> MemberRepository 라는 Interface 에 의존하지만 JDBCMemberRepository 라는 구현체 역시 의존하고 있다.
>>>
>>> DIP 원칙을 지킬 수 없다.
```JAVA
    MemberRepository m = new JDBCMemberRepository();
```

**정리**

- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성 만으로는 OCP, DIP를 지킬 수 없다.
- 뭔가 더 필요하다.

### 관심사의 분리 ( DIP, OCP )
- 하나의 객체는 하나의 기능만을 가지는 것이 개발 환경에서 중요하다.
- DIP 에서 볼 수있듯 구현 클래스 ( interface ) 에 의존 해야지 구현된 구현체에 의지해서는 안된다.
 
 주문을 넣는 class 에서 고객의 등급에 따라 할인 정책을 가져올 경우.
 할인 정책을 구현한 interface 를 통해 할인 정책을 가져와야지 구현된 구현체를 직접 선택해서는 안된다.


```JAVA
private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
```
- DIP 위배: interface 에 의지함과 동시에 구현체에도 의지를 함.
- OCP 위배: 할인 정책 변화로 RateDiscountPloicy 가 아닌 다른 것으로 변경 할 때에 코드 변경과 동시에 OCP 가 위배된다.


 이는 마치 연극의 배역을 정해두고 배우를 섭외만 해야하지 섭외된 배우가 자기 상대역까지 지정하는 셈인다.
 배우는 누가 오던 자기가 맡은 역할만 해내면 되는 것.

 공연을 구성하고, 배우를 섭외하는 것은 **공연 기획자** 가 할 일이다.

#### AppConfig
- 애플리케이션의 전체 동작 방식을 구성 (config) 하기 위해 **구현 객체 생성** 하고 **연결** 하는 책임을 가지는 별도의 설정 클래스.
- 기존의 구현 클래스와 구현체에 의존헀던 것을 막기위해 AppConfig 를 통해 생성자가 생성될 때에 구현 객체를 주입시켜 줌으로 DIP 를 지킬수 있게 된다.
- 의존 관계에 대한 고민은 외부에 맡기고 실행에만 집중 할 수 있게 된다.
- 관심사의 분리: 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리된다.
- Appconfig 를 통해 생성되는 입장에서는 본인 내부에서 의존관계를ㅌㅌㅌㅌ 호출하지 않고 생성자를 통해 외부에서 의존관계를 주입 당하기에 **DI(Dependency Injection)** 우리말로 **의존관계 주입 또는 의존성 주입** 이라고 한다.

### 스프링 빈 설정 메타 정보
- ApplicationContext 라는 interface 는 Spring 이 지원하는 핵심 interface 로 여러 기능을 가지는 interface 들을 상속 받고있다.
<img src="../../PIC/스프링 핵심원리 - 기본편/2. ApplicatonContext 제공하는 부가기능.png" style="width:100%">
---
- 스프링 컨테이너는 JAVA, XML 을 비롯한 다양한 설정 형식을 지원한다.
<img src="../../PIC/스프링 핵심원리 - 기본편/3. ApplicatonContext.png" style="width:100%">
---
- Java 는 AnnotationConfigApplicationContext 를 사용한다.
<img src="../../PIC/스프링 핵심원리 - 기본편/1. BeanFactory.png" style="width:30%">
---
- 스프링 컨테이너가 JAVA, XML 등 다양한 설정 형식을 지원가능한 이유는 스프링 컨테이너는 오직 BeanDefinition 만 읽으면 되기 때문이다.
    - 결국 역활과 구현을 잘 나눴기 때문에 어떠한 종류가 와도 같은 형식의 결과물이 나오기에 아무 지장이 없다.
- ApplicationContext 라는 interface 를 구현한 구현체들 내부에는 모두 Reader 가 있고 이들은 모두 Config 파일을 읽은 후 BeanDefinition 을 생성한다.
<img src="../../PIC/스프링 핵심원리 - 기본편/4. BeanDefinition.png" style="width:100%">

### 싱글톤 패턴 ( singleton )
- 클래스의 인스턴스가 오직 1개만 생성되는 것을 보장하는 디자인 패턴
    - 고객 한명이 요청하는 서비스만 하더라도 꽤 많은 수의 인스턴스가 생성된다.
    - 접속자가 많으면 엄청난 수의 인스턴스가 발생하는데 싱글톤 패턴을 통해 생성되는 인스턴스를 통제함으로 더 효율적으로 관리가 가능하다.
- 객체의 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.
    - private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다.
- Spring 은 기본적으로 싱글톤 패턴을 지원한다.
    - 심지어 싱글톤 패턴이 가지는 단점을 없애고 장점만 가진채로

#### 싱글톤 패턴의 단점
- 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
- 의존관계상 클라이언트가 구체 클래스에 의존한다 -> DIP를 위반한다.
- 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
- 테스트하기 어렵다.
- 내부 속성을 변경하거나 초기화 하기 어렵다.
- private 생성자로 자식 클래스를 만들기 어렵다.
- 결론적으로 유연성이 떨어진다.
- 안티패턴으로 불리기도 한다.

#### 싱글톤 패턴의 주의점
- 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱 글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지 (stateful)하게 설계하면 안된다.
- 무상태(stateless)로 설계해야 한다.
    - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!
    - 가급적 읽기만 가능해야 한다.
    - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
- 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다
    - 하나의 객체 인스턴스를 다중 클라이언트가 사용하기에 도중 원치 않은 변수의 변경이 일어난다면 큰 사고가 일어날 수 있다.

#### @Configuration 과 바이트코드
- 스프링은 CGLIB 라는 바이트 코드를 조작하는 라이브러리를 가지고 있는데 클래스에 @Configuration 어노테이션을 달고 있다면 바이트 코드 수정을 통해 싱글톤을 보장 받는다.
- AnnotationConfigApplicationContext 파라미터로 넘어간 값은 스프링 빈에 등록이 된다. 그래서 AppConfig 도 스프링빈에 등록이 된다.
- @Configuration 어노테이션을 달고있는 AppConfig 클래스의 스프링 빈을 조회해서 출력해보면
```JAVA
class hello.core.AppConfig$$EnhancerBySpringCGLIB$$bd479d70
```
- 클래스명에 CGLIB 이 붙어있다면 바이트코드 조작 라이브러리를 사용했다는 것이고 원본 클래스에 상속받은 임의의 클래스를 만들고 이를 대신해서 스프링 빈에 등록을 시킨다.
- @Bean 이 붙은 메서드가 이미 존재한다면 존재하는 빈을 반환하고 없다면 생성해서 등록해준다.
- AppConfig@CGLIB 는 AppConfig 의 자식 타입임으로 AppConfig 타입으로 조회 할 수 있다.
- @Bean 만 사용해도 스프링 빈에 등록이 되지만 싱글톤을 보장하지 않기에 기존의 JAVA 처럼 작동하게 된다.

### @ComponentScan, @Component, @Autowired
 - 기존의 스프링 빈을 등록 할 때에 @Bean 을 통해 직접적으로 등록을 했다.
 - @ComponentScan 을 통해 @Component 애노테이션이 붙은 클래스들을 스캔해서 스프링 빈에 일괄 등록해준다.
 - 기존의 직접 입력을 해주었던 의존관계 역시 @Autowired 에노테이션을 입력 스프링 빈에서 자동으로 의존관계를 주입시켜 준다.

 - @Configuration 소스코드 내부에 @Component 가 있기 때문에 컴포넌트 스캔의 대상이 된다.

#### @ComponentScan 기본 대상
- 사실 애노테이션에는 상속관계라는 것이 없다. 그래서 이렇게 애노테이션이 특정 애노테이션을 들고 있는 것을 인식할 수 있는 것은 자바 언어가 지원하는 기능은 아니고, 스프링이 지원하는 기능이다.
- 컴포넌트 스캔은 @Component 뿐만 아니라 다음과 내용도 추가로 대상에 포함한다.
- 컴포넌트 스캔의 용도 뿐만 아니라 다음 애노테이션이 있으면 스프링은 부가 기능을 수행한다.
---
- @Component : 컴포넌트 스캔에서 사용
- @Controller : 스프링 MVC 컨트롤러로 인식
- @Repository : 스프링 데이터 접근 계층에서 사용
    - 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
- @Configuration : 스프링 설정 정보에서 사용
    - 앞서 보았듯이 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.
- @Service : 스프링 비즈니스 로직에서 사용
    - 사실 @Service 는 특별한 처리를 하지 않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있겠구나 라고 비즈니스 계층을 인식하는데 도움이 된다.


#### @ComponentScan 시작 지점 설정
- 지정하지 않은 디폴트 위치는 @ComponentScan 에노테이션이 붙은 클래스의 패키지가 시작 위치가 된다.
- 컴포넌트 스캔은 모든 자바 코드를 다 뒤지는데 라이브러리 역시도 포함된다 시간을 줄이기 위한 합리적 선택
- 아래 코드를 통해 다른 컴포넌트 스캔이 시작되는 위치를 설정할 수 있다.
    - 패키지를 범위로 설정 할 수 있다.
    - 지정한 클래스의 패키지를 범위로 설정 할 수 있다.

**권장 방법**
- Appconfig 와 같은 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것. 최근 스프링 부트는 이 방법을 디폴트로 제공한다. 이렇게 되면 하위 페키지들은 자동으로 컴포넌트 스캔의 대상이된다.
- 프로젝트의 메인 설정 정보는 프로젝트를 대표하는 정보이기 때문에 시작 루트에 두는 것이 좋다.
- 스프링 부트 대표 시작 정보인 @SpringBootAplication 을 프로젝트 시작 루트 위치에 두는 것이 관례이고 이 설정안에 @ComponentScan 역시 포함되어 있다.

```JAVA
@ComponentScan(
    // 패키지가 한 개일 때
    basePackages = "hello.core"
    // 패키지가 여러 개일 때
    basePackages = {"hello.core", "hello.service"}
    
    // 지정한 클래스의 패키지
    basePackageClasses = AutoAppConfig.class
)
```

#### @ComponentScan 필터 설정
- includeFilters : 컴포넌트 스캔 대상을 추가로 지정한다.
- excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다.

```JAVA
@ComponentScan(
            includeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class),
            excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = MyExcludeComponent.class)
    )
```
##### 컴포넌트 스캔에서 빈 이름이 중복으로 등록되는 경우
1. 자동 빈 등록 vs 자동 빈 등록
    - ConflictingBeanDefinitionException 예외 발생
2. 수동 빈 등록 vs 자동 빈 등록
    - 오버라이딩 처리 : 수동 빈이 자동 빈 보다 우선권이 있다.
    - 최근에는 오류가 나도록 스프링에서 기본 설정되어 있음.



##### 어노테이션 생성
- Annotation 으로 클래스를 생성

```JAVA
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface MyIncludeComponent {

}
```
